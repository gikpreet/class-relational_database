= Boyce-Code 정규형 (BCNF)

* R: 릴레이션 스키마, X: R에 속하는 릴레이션 인스턴스의 부분집합, A: R의 속성일 때
* R이 만족하는 모든 함수 종속 X → A가 다음 중 하나에 속하면 BCNF에 속함
* A ∈ X, 즉 평범한 함수 종속
* X가 슈퍼키

---

BCNF는 원래 제 3 정규형의 간단한 형태로 제안되었으나 나중에 제 3정규형보다 더 엄격하다고 밝혀진 정규형입니다.

R을 어떤 릴레이션 스키마라고 하고 X를 R에 속하는 속성들의 한 부분집합이라고 하며 A를 R의 한 속성이라고 할 때, R이 만족하는 모든 함수 종속 X → A가 다음 중 하나에 속하면 R은 BCNF에 속합니다.

* A ∈ E, 즉 평범한 FD이거나, 또는
* X가 슈퍼키

어떤 함수 종속 집합 F가 주어졌을 때 이에 해당하는 R이 BCNF에 속하는지를 알기 위해서는, 이 정의에 따라 폐쇄 F+에 속하는 각 X → A를 모두 따져보아야 합니다. 하지만 F에 속하는 각 종속성의 왼쪽이 슈퍼키인가를 검사하는 것 만으로 충분하다는 것을 증명할 수 있습니다.

정의에 따르면 BCNF 릴레이션에 속하는 비평범 종속성들은 당연히 키가 어떤 속성들을 결정하는 형태들 뿐입니다. 따라서 이러한 릴레이션에 속하는 각 투플들은 한 키가 나머지 속성들을 묘사하는 형태의 개체이너가 관계인 것으로 볼 수 있습니다. 

> 모든 속성은 키(가 식별하는 개체 또는 관계)를 설명해야 하고, 키 전체를 설명하지만, 키 이외의 것은 아무것도 설명하지 않는다”

속성이나 속성의 집합을 타원형으로 표시하고 함수 종속을 화살표로 표시하면 BCNF에 속하는 릴레이션은 아래 그림과 같은 구조를 가집니다. (후보 키가 여러 개라면 후보 키 하나가 키의 역할을 담당합니다)
 
함수 종속 정보만 아는 경우에는 중복성의 관점에서 볼 때 BCNF가 가장 바람직한 정규형이 됩니다. 아래와 같은 릴레이션의 경우를 생각해봅시다.

[%header, cols=3, width=30%]
|===
|X	|Y	|A
|x	|y1	|a
|x	|y2	|?
|===

위 릴레이션 인스턴스는 속성이 X, Y, A 세 개가 있고 두 개의 투플을 가지고 있습니다. 이 두 투플은 X 필드의 값이 됩니다. 이 인스턴스가 함수 종속 X → A를 만족한다고 합시다. 그리고 중 한 투플의 A 필드의 값은 a 입니다. 이 정보로부터 두 번째 투플의 A 필드의 값도 a임을 추론해 낼 수 있습니다. 

이는 실제로 a라는 값이 저장된 것입니다. 이런 상황은 BCNF에서는 일어나지 않습니다. 이 릴레이션이 BCNF에 속한다면 A와 X는 서로 다르므로 X는 키이어야 합니다. 그렇지 않다면 함수 종속 X → A는 BCNF를 위배하게 됩니다. X가 키라면 y1 = y2가 되고 두 투플의 모든 속성이 같게 됩니다. 릴레이션은 투플의 집합으로 정의되어 있으므로 동일한 투플이 두 번 나타나는 상황은 발생할 수 없습니다. 

어떤 릴레이션이 BCNF에 속한다면 이 릴레이션의 한 인스턴스에 속하는 어떤 투플의 어떤 필드에 속하는 정보도 나머지 필드 정보 들로부터 함수 종속만 사용해서 유도해 낼 수 있습니다.
아래 릴레이션에서,

----
Parttime_emp(EmpID, Name, Parkingslot, Grade, WagePerHr, Workingtime)
               E     M         P         G        W            T
----

이 릴레이션인 속성이 EMPGWT이고 두 함수 종속, E → EMPGWT와 G → W을 가지고 있습니다. G가 키가 아니고 W가 키의 일부가 아니기 때문에 두 번째 함수 종속은 3NF를 위반합니다.

설계를 다시 해서, 속성이 EMGPT인 릴레이션과 속성이 GW인 릴레이션을 만들면 됩니다. EMPGT에서는 E → EMPGT가 만족되고 E가 키이며, GW에서는 G → W가 만족되고 G가 키입니다. 이 두 스키마에서 만족되는 다른 함수 종속은은 첨가 법칙으로 얻어지는 것 들 뿐입니다. 따라서 두 스키마는 모두 BCNF에 속합니다.

link:./14_decompsotion.adoc[다음: 분해]