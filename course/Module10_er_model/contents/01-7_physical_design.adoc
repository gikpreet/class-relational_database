= 물리 설계

* 논리 데이터 모델을 실 환경 DBMS에서 효율적으로 운영할 수 있도록 구현하느 과정
* 논리 설계를 기반으로 데이터베이스를 최적화하여 성능을 향상시키는 과정
* 중점 사항
** 데이터 처리 속도 향상을 위한 성능 최적화
** 디스크 및 메모리 사용량을 줄이기 위한 저장 공간 효율화
** 데이터 무결성 유지
** 인덱스, 파티셔닝 등을 활용하여 검색 성능 개선을 통한 효율적인 접근 및 관리

---

물리 설계는 논리 데이터 모델을 실제 데이터베이스 관리 시스템(DBMS)에서 효율적으로 운영할 수 있도록 구현하는 과정입니다. 물리 설계 단계는 논리 설계를 기반으로 데이터베이스를 최적화하여 성능을 향상시키는 과정입니다.

== 저장 구조 설계

논리 설계에서 도출된 테이블을 DBMS의 물리적 저장 구조에 맞게 변환하며, 도메인에 매칭되는 데이터 타입을 적절히 설정하여 저장공간을 최적화합니다.

* 정수 vs 실수: 불필요한 실수형(float, double) 대신 정수(int, bigint) 사용
* 가변 길이 vs 고정 길이 문자형: 데이터 크기에 따라 VARCHAR vs CHAR 선택
* 날짜 및 시간 데이터 타입 선택: DATE, DATETIME, TIMESTAMP 활용
* DBMS에 맞는 최적화된 데이터 타입을 선택

== 인덱스 설계

검색 성능을 최적화하기 위해 인덱스를 생성하며, 자주 조회되는 컬럼을 기준으로 클러스터/넌 클러스터 인덱스를 생성합니다.

* 기본 키 컬럼에 클러스터드 인덱스가 자동으로 생성되는 DBMS의 경우, 성능을 위해 대리 키를 고려
* 검색, 정렬, 조인에 자주 사용되는 컬럼에 넌 클러스터드 인덱스 추가
* 인덱스가 과도한 경우 삽입/수정 성능이 저하됨

== 테이블 파티셔닝

대용량 데이터 처리를 위해 테이블을 여러개의 파티션으로 분할하여 성능을 향상시킬 수 있습니다. 범위, 해시, 리스트 파티셔닝 기법을 활용합니다.

* 날짜 기준으로 Range Partitioning 적용 → 예: 2023년 데이터, 2024년 데이터
* 고객 ID 기준으로 Hash Partitioning 적용 → 예: 고객ID % 4

== 비 정규화

데이터 조회 성능을 고려하여 비정규화(Denormalization)를 적용할 수 있습니다. 조인이 많아 성능 저하가 예상될 경우, 중복 데이터를 일부 허용하여 성능 개선할 수 있습니다.

* 읽기 성능을 우선하는 경우 → 반정규화
* 쓰기 성능을 우선하는 경우 → 정규화 유지

== 요약

[%header, cols="1,2,2"]
|===
|구분|논리 설계 (Logical Design)|물리 설계 (Physical Design)
|목적|데이터 모델 정의 및 정규화|성능 최적화 및 저장 구조 설계
|주요 작업|엔티티, 속성, 관계 정의|인덱스, 파티셔닝, 저장구조 최적화
|사용 도구|ERD(Entity-Relationship Diagram)|SQL (DDL, 인덱스, 파티셔닝)
|예제|"학생과 학과는 1:N 관계"|"학생 테이블에 학과명을 반정규화하여 추가"
|===

== 고려사항

* 디스크 I/O 최소화 → 인덱스 활용, 파티셔닝 적용
* 캐싱(Cache) 및 메모리 활용 → 자주 조회되는 데이터는 뷰(View)로 제공
* 트랜잭션(Transaction) 부하 분산 → 테이블 락 최소화, 분산 DB 적용
* 읽기/쓰기 최적화 → 정규화와 반정규화의 균형 유지
* 백업 및 복구 전략 수립 → 장애 발생 시 데이터 손실 방지
* 재해 대응 전략 및 구현 → 장애 조치 클러스터, 읽기 전용 복제, RAC 등 고려

---


link:./01-6_schema_refine.adoc[이전: 스키마 정제] +
link:./02-1_chapter2_ER_model.adoc[다음: Chapter 2: 개체 관계 데이터모델]