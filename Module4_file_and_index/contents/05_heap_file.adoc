= Heap 파일

* 정렬되지 않은 단순한 형태의 파일
* 스캔 B(D+RC)
* 동등 셀렉션
후보 키에 대한 연산일 경우 0.5B(D+RC). 후보 키가 아닌 경우 스캔과 동일
* 범위 셀렉션
스캔과 동일
* 삽입
레코드가 항상 파일의 끝에 삽입된다고 가정할 경우 2D+C
* 삭제
탐색 비용 + C + D

---

Heap 파일은 정렬되지 않은 가장 단순한 형태의 파일입니다. 기본 순서 없이 저장되는 구조이며, 데이터가 Heap에 삽입되면 페이지가 어디에 기록되는지 확인할 방법이 없고, 해당 페이지가 테이블에 기록되거나 유지 관리가 수행될 때 동일한 순서로 유지된다는 보장도 없습니다.

논리적으로 Heap은 Heap 내의 모든 페이지를 가리키는 IAM(Index Allocation Map)으로 구성됩니다. 각 페이지에는 기록되는 만큼의 데이터 row가 포함됩니다. Heap 내에서는 페이지간의 연결이나 구성이 없으며, 모든 읽기 및 쓰기는 IAM을 참조한 다음 Heap내의 페이지를 읽습니다. 

Heap 파일에서 각각의 연산에 대한 비용은 아래와 같이 계산됩니다.

* 스캔 +
B의 페이지를 각각 검색해야 하는데 페이지 당 D의 시간이 소요되며, 각각의 페이지에 대해 R개의 레코드를 처리해야 하는데 레코드 당 C의 시간이 소요되기 때문에 총 비용은 B(D+RC)입니다.
* 동등 셀렉션 +
검색하고자 하는 조건이 후보 키 중의 하나여서 연산의 결과가 하나의 레코드임이 보장된다면 평균적으로 파일의 절반을 스캔하는 시간이 필요합니다. 그리고 검색된 데이터 페이지마다 그 안에 들어있는 모든 레코드에 대해 해당 레코드인지 검사하는 작업이 필요합니다. 이 경우 비용은 0.5B(D+RC)입니다. 
후보 키가 아닌 필드에 대한 셀렉션인 경우에는 스캔과 동일합니다.
* 범위 셀렉션 +
조건에 맞는 레코드들이 파일 전체에 걸쳐 여러 개가 존재할 수 있으므로 항상 파일 전체를 스캔해야 합니다. 비용은 B(D+RC)입니다.
* 삽입 +
레코드가 항상 파일의 끝에 삽입된다고 가정할 때, 파일의 마지막 페이지를 로드해서 레코드를 추가하고 저장해야 합니다. 비용은 2D+C입니다.
* 삭제 +
먼저 레코드를 찾고 해당 페이지에서 레코드를 삭제한 후, 수정된 페이지를 다시 저장해야 합니다. 비용은 탐색 비용에 C+D를 더한 것과 같습니다.

link:./06_sorted_file.adoc[다음: 정렬 파일]