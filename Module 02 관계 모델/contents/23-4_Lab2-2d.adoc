= Lab 2-2c: SQL을 사용한 무결성 제약조건 설정(Postgres)

== 연습 1 SQL을 사용하여 개체 무결성을 위한 기본 키 제약조건 설정

이 연습에서는 SQL을 사용하여 연습 2-1에서 생성한 릴레이션에 무결성 제약조건을 설정합니다. 도메인 제약조건은 릴레이션 스키마에 이미 정의되어 적용되었으므로, 개체 무결성과 참조 무결성을 유지하기 위한 무결성 제약조건을 설정합니다. 아래 절차에 따릅니다.

=== Postgres에 접속하고 현재 데이터베이스 설정

1. macOS와 Linux에서는 터미널, Windows에서는 명령 프롬프트를 실행합니다.
2. 아래 명령을 실행하여 Postgres 콘솔에 접근합니다.
+
----
psql -U postgres
----
+
3. 아래 명령을 수행하여 DBMS에 생성된 데이터베이스를 확인합니다.
+
----
SELECT datname FROM pg_database;
----
+
질의의 수행 결과는 아래와 유사할 것입니다.
+
----
  datname
-----------
 postgres
 module02
 template1
 template0
(4 rows)
----
+
4. 아래 질의를 수행하여 현재 데이터베이스를 확인합니다.
+
[source, sql]
----
SELECT current_database();
----
+
질의의 수행 결과는 아래와 유사할 것입니다.
+
----
 current_database
------------------
 postgres
(1 row)
----
+
5. 아래 명령을 수행하여 현재 데이터베이스를 module02로 변경합니다.
+
----
\c module02
----
+
명령의 실행 결과는 아래와 유사할 것입니다.
+
----
You are now connected to database "module02" as user "postgres".
----
+
6. 아래 질의를 수행하여 현재 데이터베이스를 확인합니다.
+
[source, sql]
----
SELECT current_database();
----
+
질의의 수행 결과는 아래와 같을 것입니다.
+
----
 current_database
------------------
 module02
(1 row)
----

=== Category 릴레이션에 기본 키 제약조건 설정

1. 아래 명령을 실행하여 module02 데이터베이스에 생성된 릴레이션(테이블)들을 확인합니다.
+
----
\dt
----
+
명령의 실행 결과는 아래와 유사할 것입니다.
+
----
          List of relations
 Schema |   Name   | Type  |  Owner
--------+----------+-------+----------
 public | category | table | postgres
 public | product  | table | postgres
(2 rows)
----
+
2. 아래 질의를 수행하여 Category 테이블의 스키마 정보를 확인합니다.
+
[source, sql]
----
SELECT column_name, data_type FROM information_schema.columns WHERE table_name='category';
----
+
----
 column_name  |     data_type
--------------+-------------------
 categoryno   | integer
 categoryname | character varying
(2 rows)
----
+
3. 아래 질의를 수행하여 Category 테이블의 CategoryNo 컬럼에 기본 키 제약조건을 추가합니다.
+
[source, sql]
----
ALTER TABLE Category ADD CONSTRAINT pk_category PRIMARY KEY(CatregoryNo);
----
+
----
ALTER TABLE
----
+
4. 아래 질의를 수랭하여 Category 테이블에 생성된 제약 조건을 확인합니다.
+
[source, sql]
----
SELECT constraint_name, column_name, constraint_type FROM information_schema.constraint_column_usage AS c NATURAL JOIN INFORMATION_SCHEMA.TABLE_CONSTRAINTS AS T WHERE T.table_name = 'category';
----
+
----
 constraint_name | column_name | constraint_type
-----------------+-------------+-----------------
 pk_category     | categoryno  | PRIMARY KEY
(1 row)
----
5. 아래 질의를 실행하여 Category 테이블의 데이터를 확인합니다.
+
[source, sql]
----
SELECT * FROM Category;
----
+
----
 categoryno | categoryname
------------+--------------
          1 | Novel
          3 | History
(2 rows)
----
+
6. 아래 질의를 실행하여 Category 테이블에 데이터를 삽입합니다.
+
[source, sql]
----
INSERT INTO Category (CategoryNo, CategoryName) VALUES (3, 'Science');
----
+
질의는 성공적으로 수행되지 않습니다. Category 테이블에 개체 무결성을 위한 기본 키 제약조건(Primary Constraint)이 적용되었고, 기본 키 제약조건에 해당하는 컬럼은 종복되는 값을 저장할 수 없습니다. 결과는 아래와 같습니다.
+
----
ERROR:  duplicate key value violates unique constraint "pk_category"
DETAIL:  Key (categoryno)=(3) already exists.
----

=== Product 테이블에 기본 키 제약조건 설정

1. 아래 명령을 실행하여 Product 테이블의 스키마 정보를 확인합니다.
+
[source, sql]
----
SELECT column_name, data_type FROM information_schema.columns WHERE table_name='product';
----
+
----
 column_name |     data_type
-------------+-------------------
 productno   | integer
 price       | money
 category    | integer
 productname | character varying
(4 rows)
----
+
2. 아래 질의를 수행하여 product 테이블의 productno 컬럼에 기본 키 제약조건을 추가합니다.
+
[source, sql]
----
ALTER TABLE Product ADD CONSTRAINT pk_Product PRIMARY KEY(ProductNo);
----
+
----
ALTER TABLE
----
+
3. 아래 질의를 수행하여 Product 테이블에 생성된 제약 조건을 확인합니다.
+
[source, sql]
----
SELECT constraint_name, column_name, constraint_type FROM information_schema.constraint_column_usage AS c NATURAL JOIN INFORMATION_SCHEMA.TABLE_CONSTRAINTS AS T WHERE T.table_name = 'product';
----
+
질의의 수행 결과는 아래와 유사할 것입니다. product 테이블의 productNo 필드에 기본 키 제약 조건이 적용되었습니다.
+
----
 constraint_name | column_name | constraint_type
-----------------+-------------+-----------------
 pk_product      | productno   | PRIMARY KEY
(1 row)
----
+
4. 아래 질의를 수행하여 Product 테이블의 데이터를 확인합니다.
+
[source, sql]
----
SELECT productNo, productname, price, categoryno FROM Product;
----
+
----
 productno | productname | price | categoryno
-----------+-------------+-------+------------
(0 rows)
----
+
5. 아래 질의를 수행하여 Product 테이블에 데이터를 삽입합니다.
+
[source, sql]
----
INSERT INTO Product (ProductNo, ProductName, Price) VALUES (20101927, 'The Second World War', 37800);
----
+
----
Query OK, 1 row affected (0.02 sec)
----
+
6. 아래 질의를 수행하여 Product 테이블의 데이터를 확인합니다.
+
[source, sql]
----
SELECT * FROM Product;
----
+
----
 productno | productname | price | categoryno
-----------+-------------+-------+------------
(0 rows)
----