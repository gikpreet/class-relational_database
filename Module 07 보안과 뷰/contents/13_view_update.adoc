= 뷰에 대한 갱신

* 사용자는 뷰와 기반 테이블을 갱신할 필요가 없어야 함
* SQL 92 표준에서는 뷰에 대한 갱신 기준을 정의
** 하나의 기반 테이블에 대해서 셀렉션 및 프로젝션 만으로 진행되고 집단 연산을 사용하지 않는 뷰에 대해서만 갱신을 허용
** 갱신 가능 뷰(Updateable View)

---

뷰 메커니즘의 원래 동기는 외부 스키마의 구성을 위해 사용자별로 데이터를 보는 관점을 맞추어 주는 것입니다. 따라서 사용자는 뷰와 기반 테이블을 구분할 필요가 없어야 합니다. 뷰에 대해 질의를 할때는 이 목표가 만족됩니다. 하지만 뷰를 갱신하고자 할 때는 뷰와 기반 테이블 사이의 차이점을 염두에 두어야 합니다.

뷰 FlightInfo는 Flight 테이블과 Aircraft 테이블을 기반해 작성되었습니다.

Flight 테이블

[%header, cols="1,1,1,1,1,2", width=90%]
|===
|FlightNo	|AircraftNo	|Deparetures	|Arrival	|Price	|FlightDate
|1	|101	|인천	    |샌프란시스코	   |1230000	|2022-10-23 10:20:00
|2	|101	|샌프란시스코	|인천	|1320000	|2022-10-26 13:00:00
|3	|105	|김포	    |제주	|72000	|2022-11-23 09:00:00
|4	|105	|김포	    |김해	|68000	|2022-11-12 17:30:00
|5	|103	|인천	    |프랑크푸르트	|1480000	|2022-12-01 18:00:00
|6	|103	|프랑크푸르트	|인천	|1560000	|2022-12-10 10:00:00
|7	|104	|김해	    |김포	|70000	|2022-11-13 11:00:00
|8	|101	|인천	    |샌프란시스코	|1230000	|2022-11-15 10:00:00
|===

[%header, cols="1,1,1", width=50%]
|===
|AircrafNo	|KindOfaircraft	|Airline
|101	|Boeing 747	|대한항공
|102	|Boeing 727	|대한항공
|103	|Airbus A380	|아시아나 항공
|104	|Airbus A300	|대한항공
|105	|Boeing 737-800	|제주항공
|===

FlightInfo 뷰는 두 테이블을 조합하여 만들어졌습니다.

[%header, cols="1,2,2,2,2,2", width=90%]
|===
|No	|Aircraft	|Airline	|FromPort	|InPort	|Price
|1	|Boeing 747	|대한항공	|인천	|샌프란시스코	|1230000
|2	|Boeing 747	|대한항공	|샌프란시스코	|인천	|1320000
|3	|Boeing 737-800	|제주항공	|김포	|제주	|72000
|4	|Boeing 737-800	|제주항공	|김포	|김해	|68000
|5	|Airbus A380	|아시아나 항공	|인천	|프랑크푸르트	|1480000
|6	|Airbus A380	|아시아나 항공	|프랑크푸르트	|인천	|1560000
|7	|Airbus A300	|대한항공	|김해	|김포	|70000
|8	|Boeing 747	|대한항공	|인천	|샌프란시스코	|1230000
|===

FlightInfo 뷰의 No 컬럼은 Flight 테이블의 FlightNo 컬럼을 기반으로 합니다. FlightInfo 뷰에서 No 컬럼의 값이 1인 투플을 삭제하는 경우를 생각해봅시다. FlightNo 뷰의 컬럼들은 실제로 저장되어 있지 않고, 필요할 때 Flight 테이블과 Aircraft 테이블에서 뷰 정의를 이용해서 계산해 냅니다. 따라서, FlightInfo 뷰에서 No1가 1인 투플을 삭제하려면 Flight 테이블의 FlightNo가 1인 투플과 Aircraft 테이블에서 AircraftNo 컬럼이 101인 투플 모두를 삭제해야 합니다. 

이 경우, Aircraft 테이블에서 AircraftNo가 101인 투플을 삭제하면 Flight 테이블에서는 FlightNo 컬럼의 값이 1, 2, 8인 세 투플이 삭제되어야 하는 부작용이 생깁니다. 이런 경우 사실 유일한 해결책은 뷰에 대한 갱신을 불허하는 것입니다. 아래와 같은 FlightInto 뷰에 대한 삭제 쿼리는 허용되지 않습니다.

----
mysql> DELETE FROM FlightInfo WHERE no = 1;
ERROR 1395 (HY000): Can not delete from join view 'module06.flightinfo'
----

SQL 92 표준에서는 하나의 기반 테이블에 대해 셀렉션 및 프로젝션만으로 정의되고 집단 연산은 사용하지 않는 뷰에 대해서만 갱신을 허용합니다. 이런 뷰들을 갱신 가능 뷰(Updatable View)라고 합니다. 

뷰를 생성한 사용자는 그 뷰를 정의할 때 모든 뷰나 기반 테이블에 대해 가지고 있는 특권들과 똑 같은 특권들을 그 뷰에 대해 가집니다. 뷰를 생성하는 사용자는 각 기반 테이블에 대해 SELECT 특권을 가지고 있어야 하므로, 이에 따라 그 뷰에 대해서도 SELECT 특권을 항상 부여 받습니다. 뷰의 생성자는 모든 기반 테이블에 대해 허가권이 부여된 SELECT 특권을 가지고 있을 때에 한해서 그 뷰에 대해 허가권이 부여된 SELECT 특권을 가집니다. 또한 뷰가 갱신 가능형이며 사용자가 기반 테이블 중 일부에 대해서 INSERT, DELETE, UPDATE 특권을 가지고 있다면 그 사용자는 자동적으로 그 뷰에 대한 동일한 특권을 가집니다.

link:./14_lab7-2.adoc[다음: 연습 7-1 뷰의 사용 및 보안 설정]